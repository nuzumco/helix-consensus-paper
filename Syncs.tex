The following section illustrates an algorithm for syncing a node to the present \emph{state of the system} (loosely speaking, the state of the system relates to the blockchain up to the term number of the most advanced correct node). It is desired to perform the syncing procedure as fast as possible, without sacrificing \nameNS's safety. Intuitively, having a quick syncing mechanism, reduces the effective time a node is considered faulty (sleepy) and thus, helps in reducing $f$. Reducing the number of faulty nodes enhances the performance of the system.

%In our model we assume a small number of faulty nodes. Since our protocol runs indefinitely, in order to justify this assumption, a recovery mechanism for corrupted nodes is crucial. Intuitively, having a quick syncing mechanism, reduces the effective time a node is considered faulty (sleepy) and thus, helps in reducing $f$ and achieving $f\ll n$. In addition, it contributes to the liveness of the system. Recovering a node requires a two step procedure - first, a corrupted node needs to be detected and restarted (with correct code); then, it needs to be synced to the present \emph{state of the system} (loosely speaking, the state of the system relates to the blockchain up to the term number of the most advanced correct node). In this section, we are concerned with the second step\footnote{The first step can be tackled with a proactive approach as done in PBFT~\cite{PBFT}. For the time being, \name takes a different approach by which we rely on human intervention (e.g. a node's administrator) for making sure a node is not corrupted (by conducting periodic checkups and reboots).} and elaborate on the syncing procedure of a recovered node.

%Syncing may take very long if a node has much data to recover. According to our description thus far, a node needs to complete syncing prior to safely realizing its membership in a committee and taking part in it. We emphasize that as long as a recovered node cannot participate in a committee it is considered faulty (specifically, sleepy). We now illustrate a minor modification in our protocol that enables a more efficient syncing procedure that allows a recovered node to nearly instantaneously realize its membership status and act accordingly.

A straightforward way for a node ($i$) to sync is by sending some node ($j$) a request to sync that contains the highest term for which she has a Dblock ($DB^r$). If $j$ has higher term committed Eblocks, she sends $i$ tuples of the form ($EB^q$, $BP^q$, $SB^q_0$, \dots, $SB^q_t$) for $q>r$ in an incrementing manner. Upon receiving the $(r+1)$-term tuple, $i$ verifies $BP^{r+1}$ as a valid Block-proof for $EB^{r+1}$ under the $(r+1)$-term committee (as determined by $DB^r$). $i$ then appends $EB^{r+1}$ and reveals $DB^{r+1}$ and the committee for term $r+2$ (using $SB^{r+1}_0, \dots , SB^{r+1}_t$). This process is performed repeatedly until $j$ completes sending all its blockchain. If $j$ itself is \emph{in-sync with the network}, then once the process is terminated, $i$ is successfully synced.
%\footnote{We note that in PoW type blockchains, as long as syncing is in progress miners cannot participate in extending the chain as they have no way to evaluate the validity of a block before they are certain of the preceding block's authenticity. This is also true in Algorand \cite{AlgorandV9} which is problematic for lazy honesty, because lazy nodes need to sync all blocks before their "turn" begins.}.
The downside of this method is that it might take a node a long time to sync (especially when syncing after a long downtime) during which the node is considered faulty and cannot participate in committees.

The \name fast sync algorithm enables a node to actively participate while the previously described syncing procedure is taking place. A node $i$ constantly listens to the network and learns the current term number, $r$, from the received messages. Upon receiving a message that contains a Block-proof and a matching Eblock (i.e., $\langle EB^r, BP^r\rangle$) $i$ validates $BP^r$. Particularly, in the fast sync optimization, $i$ drops the Cmap brief-validation check as defined in Sec.~\ref{segment3}. If found valid, we claim that $i$ is safe to append $EB^r$ to her blockchain, even though $i$ does not have $DB^{r-1}$ and can not calculate locally Cmap$^r$ (or the committee in term $r$) and relies on $EB^r$'s header for it. 

We emphasize that if $i$ receives segment 4 messages (i.e., committee-related messages such as pre-prepare, prepare, etc.) she may assume that it is in the $r$-term PBFT committee. But since $i$ does not have the previous Dblock yet, she cannot reassure it and thus cannot participate. Thus, in this term, $i$ still counts as faulty. In particular, if $i$ is primary in this term, she would lose her turn.

We now turn to prove that Helix is safe when nodes apply the fast sync optimization.
\begin{claim}{(Fast syncing safety)}
%Let $u_1,\dots,u_n$ be $n$ nodes running \name with the fast syncing optimization, and denote by $u_i$ the first correct node to append an Eblock in term $r$, denoted $EB^r_i$. Let $u_j$ be an arbitrary correct node that appended an Eblock in term $r$, denoted $EB^r_j$. Then, $EB^r_i=EB^r_j$.
Let $0,\dots,n-1$ be the nodes running \name with the fast syncing optimization. In term $r$, let $EB^r_i$ and $EB^r_j$ be Eblocks appended by correct nodes $i,j\in [n-1]$, respectively, to their local blockchains. Then, $EB^r_i=EB^r_j$.
\end{claim}

\begin{proof}
The proof is very similar to the original safety proof given in Sec.~\ref{section_properties_safety}. It relies on PBFT's safety which suffices as long as the committee in term $r$ is a well-defined set of $m$ nodes, which is agreed upon by all nodes. 
%We thus focus on showing that $C^r$ is indeed well-defined also after introducing the fast sync optimization. 
Let $C^r$ be the committee that arises from $DB^{r-1}$. As in the original safety proof, an inductive argument convinces that $DB^{r-1}$ is agreed-upon and thus $C^r$ is indeed well-defined. This is not enough though, as the fast sync optimization enables nodes to deduce the committee of term $r$ from $EB^{r}$ (rather than learn it locally from $DB^{r-1}$). However, for a correct node to deduce the committee of term $r$ from $EB^{r}$, the latter must be accompanied by a valid Block-proof. Since correct nodes would contribute their signatures to a Block-proof only if they can calculate $C^r$ locally and validate that it matches $EB^r$'s Cmap, no Block-proof for a term-$r$ Eblock that contradicts $C^r$ can be generated. This concludes that $C^r$ is indeed well-defined and PBFT's safety proof is now applicable.
\end{proof}
%Old proof - too long 
% We prove the claim by induction on $r$. We split the proof into three sections.
% \begin{itemize}
% \item We first show that \emph{the committee of term $r$}, denoted $C^r$ is a well-defined set of $m$ nodes. This remains the same as in the original safety proof in~\ref{section_properties_safety}. 

% \item We then show, from safety in PBFT, that any two valid $r$-term Block-proofs correspond to the same $r$-term Eblock. 
% %This is the only item that needs a new proof. It might be the case that a fake Block-proof can be constructed such that nodes that do not know $C^r$ consider it valid and thus append an inconsistent Eblock in term $r$. The reason this needs a new proof is because the validation process of non-committee members slightly changed under the fast syncing optimization as described above. 
% According to the fast sync optimization, a correct node only verifies that all the signers appearing in $BP^r$ are indeed committee members according to the header of $EB^r$. It is thus left to show that it cannot be that the committee appearing in $EB^r$ is any different to $C^r$. Assume by negation that this is indeed the case, i.e., the Cmap in $EB^r$ is different to $C^r$. This would immediately contradict our assumption of at most $f$ Byzantine nodes in the network. No correct node would sign a pre-prepare message that contains an invalid Eblock, and in particular an Eblock that contains an incorrect committee. A correct member either does not know $C^r$ (meaning it did not calculate it locally) and would thus not sign any prepare messages (even if it is in $C^r$), or knows $C^r$ and would thus only sign valid prepare messages, that in particular attest to the rightful committee (specifically, it would not sign a pre-prepare message proposing $EB^r$). A correct non-committee member would never sign any pre-prepare (or other PBFT related) messages in term $r$. Thus, at most $f$ nodes would sign pre-prepare messages proposing $EB^r$ and there is no way a valid Block-proof could be constructed for it. 

% \item Finally, we show that $EB^r_i=EB^r_j$ for any correct node $u_j$ as needed. This remains the same as in the original safety proof.
% \end{itemize}

%\red{until now, there was strong consistency with no holes... Problem: desynchronized Epools of a node that missed a few Eblocks and fast-synced and is now primary but did not get all blocks until now.}