%basic motivation
%mass-market consumer applications on the one hand. The decentralized boom on the other hand. The combination of the two is inevitable. It cannot be done with today's distributed technologies via open networks and slow consensus based on PoW. PoS is another incompatible alternative. Basic motivation for a permissioned network and cheap consensus (no PoW).
In the past two decades, mass-market consumer applications have enjoyed increasing popularity, to the extent that today, many individuals around the world run a significant portion of their day-to-day activities via such services and apps. Such applications typically handle billions of requests daily\footnote{\url{https://blog.whatsapp.com/10000631/Connecting-One-Billion-Users-Every-Day} and \newline \url{https://blog.twitter.com/engineering/en_us/a/2013/new-tweets-per-second-record-and-how.html}}, with instant process time for providing good user experience. The extremely high valuations of some of these services today\footnote{\url{https://newsroom.fb.com/news/2014/02/facebook-to-acquire-whatsapp/}} originate from their large user bases and their ability to inter-connect between them seamlessly and efficiently. Such apps include highly popular telecommunications, messaging or general social networks, transport and accommodation platforms, and many more. 
%%Fundamentally, these applications connect between peers sharing corresponding needs and desires and could be supported by decentralized architectures. Today, however, instead of directly connecting peers, these services run their communication via centralized servers. This requires users to trust the service operator in many ways.  
These peer-to-peer services naturally fit decentralized frameworks, where the control of app operators can be distributed among numerous entities (bypassing the single point of failure problem) and partially transferred to the users themselves. Today however, the vast majority of these applications are still managed via centralized operators.

%with estimated value of transactions at the billions of US dollars \red{daily? yearly?}, and . Most of these services are based on the ability to connect between users in peer-to-peer transactions and obtain their value from the mass adoption of these users. Such apps include highly popular telecommunications, messaging or general social networks, transport and accommodation platforms, and many more. Despite the natural fit of peer-to-peer applications to decentralized architectures and the advantages such pairing could bring, the vast majority of these applications are run via centralized services. 

This remains true also after the emergence of secure and open decentralized networks for code execution (smart contracts) and state replication such as Bitcoin and Ethereum. Recently, these types of solutions have gained wide adoption and were proven to solve the single point of failure problem while reducing the trust users put in service providers. 

We maintain, however, that the current generation of consensus protocols used in these platforms are ill-suited for the needs of mass-market consumer applications. The most significant of those, the Nakamoto consensus via Proof-of-Work (PoW), struggles with processing large volumes of transactions, takes long to confirm new transactions, and requires huge energy waste when securing large economic values. Proof-of-Stake (PoS) protocols may become a better alternative, but these are highly unpredictable at this point and were not yet proven by a fully functioning implementation. Furthermore, according to the PoS paradigm, the entities that control the network are those with the most stake, while we stress that for the needs of mass-market consumer applications it should be the app operators that control the platform in some distributed manner. Concord is a consensus protocol specifically designed for the needs of large scale consumer services, and is run by a set of consensus nodes they determine. 
The protocol may accommodate different governance mechanisms that allow to add or remove nodes frequently.
\red{OR: The protocol assumes a list of consensus nodes responsible to construct and validate a block. Such a list can be defined and modified frequently with different governance mechanisms - permissioned, where a new node needs to be approved by an existing federation of nodes; or permissionless, based on stake in the system or other criteria. Through the course of this paper we assume a static set of consensus nodes for simplicity.}

%requirements
%More detailed and specific requirements should be presented: finality+speed+volume=need; network growth -> committees; resilience to attacks (crashes, bugs in code, deliberated attacks) -> PBFT, re-election of committees; fairness.

%Carefully written and checked requirements led us in the design of Concord and guided us in settling subtle trade-offs. A few of the more important requirements that a \red{distributed platform} should satisfy in order to comply with the current needs of common mass-market consumer applications, as we identified, are presented now. 

First, it needs to provide its users with conclusive confirmation of transactions in limited time, a property known as \emph{finality}. This should be maintained also when transactions are issued in high rate and large volumes.
Second, as the network grows, we require that its performance does not deteriorate. As consensus is inherently more complex in larger networks, the latter requirement can be resolved by confining the agreement process to a bounded-size committee, selected from the overall consensus nodes. We further require the re-election of these committees to be frequent and unexpectable in order to provide resilience against attacks. 
Lastly, a few notions of \emph{fairness} should be addressed by the protocol. Our main objective is to ensure a fair distribution of power between the nodes and to guarantee the ordering of transactions does not reflect one's individual interests. In addition, fairness should protect end users from being censored. A general principle, followed by Concord, that can help achieve this requirement is assuring nodes are ignorant as to the content of transactions until a final order is reached.

%Design patterns
Since the rise of Bitcoin, distributed and decentralized technologies have been booming with all sorts of novel ideas being suggested. These technologies aim to improve certain aspects of the original PoW-based blockchain protocol. While some of these technologies show promising future, they have not yet gained the sufficient mileage to be considered as robust solutions for high value markets (a good survey that examines several blockchain protocols is~\cite{blockchain_in_wild}). Technologies based on block-DAGs serve as good examples for recently suggested solutions to some scalability and speed issues with PoW (these include IOTA~\cite{IOTA}, SPECTRE~\cite{Spectre} or PHANTOM~\cite{Phantom}). Federated consensus, developed by Stellar~\cite{Stellar} and Ripple~\cite{Ripple} is yet another unproven approach that aims to "open" classic consensus protocols that operate under closed networks. Another interesting example is Tangaroa~\cite{Tangaroa}, a presumably Byzantine version of Raft~\cite{Raft}, that gained increasing popularity before shown to be broken~\cite{blockchain_in_wild}. 
%New techniques to improve privacy have gained much success with fancy cryptography magic (Monero with ring signatures and Zcash with zk-SNARKs) while scaling, sharding etc have enjoyed much less success (block-DAGs as IOTA and COTI). We, as some other projects do, put our main emphasis on classical well-tested and empirically-proven consensus approaches (unlike Tangaora) and cryptosystems.

Considering these examples and many others, in the construction of Concord, we limited ourselves to widely accepted algorithms from distributed computing and cryptography, that were tested in production systems over long periods of time. Concord combines such building blocks in a unique manner to address the requirements presented above. Another design rationale that emphasizes Concord's robustness was to prioritize safety over other properties. This means that for safety to break more assumptions need to be found false.

The basic protocol with which Concord achieves agreement over a block is the known PBFT~\cite{PBFT}. As a matter of fact, Concord can be interpreted as a blockchain construction on top of PBFT, based on adaptive and randomly-elected committees, which enables to run many individual instances of PBFT sequentially, each responsible for a single value (block). Concord inherits PBFT's finality property, i.e., natural forks in the blockchain can never occur. Additionally, while PBFT becomes slow under frequent primary changes, Concord maintains its efficiency while supporting primary replacements every block. The committee size is determined according to the strictest bound on the number of faulty nodes that can be assumed. In PBFT, if this bound is smaller than $\lfloor \frac{n-1}{3} \rfloor$, then the performance is not optimized. Whereas in Concord, performance is optimized via setting the elected committee's size to be $m=3f+1$, which is the smallest committee size that reproduces PBFT's results.

Concord focuses solely on the ordering of transactions. It does not relate any semantics to the transactions it orders and is completely unaware of a state these transactions produce by the operations they invoke. It thus becomes possible to have nodes completely blind to the transactions they order. This is achieved with a threshold encryption scheme that obfuscates the transactions from the entities engaged in the consensus protocol. Only when the order has been finalized and can no longer be modified is the content of the transactions revealed. The threshold encryption scheme, in its turn, can be further used to produce publicly-verifiable randomness within the protocol. As was shown in~\cite{BticoinPublicRandomSource}, public randomness is produced also in the Bitcoin blockchain. While in Bitcoin this is a side effect, in Concord the randomness is used in two different places. First, we realize a correlated sampling scheme that is used to emulate random sampling of one's pool of pending transactions. Second, to elect the committees mentioned above in a non-predictable or manipulable manner.

%Paper overview
The remainder of the paper is organized as follows. We begin with a short background that covers basic concepts in distributed systems and a few cryptography primitives used by Concord. Then, in Sec.~\ref{section_model} we describe our system model. In Sec.~\ref{section_Protocol} we give a detailed description of the Concord protocol. Sec.~\ref{section_properties} is dedicated to prove basic properties Concord satisfies. In Sec.~\ref{section_highload} we focus on epochs with high transaction rate and suggest a sampling scheme to construct blocks in a fair manner. Finally, in Sec.~\ref{section_syncs} we propose a method to sync nodes rapidly. 

%One of Nakamoto consensus' side-effects is publicly-verifiable randomness. In Concord, we utilize the decryption process of encrypted transactions to realize a verifiable random function. As opposed to Bitcoin, this randomness does not come with a price tag, but is to be trusted so long as our model assumptions hold, specifically, that there are at most $f$ Byzantine nodes. The public randomness is used twice - first, to sort the participants and select a sub-group of those that will actively participate in the agreement protocol and produce a new committed value (block in the blockchain). Second, to realize a correlated sampling scheme . In general, public randomness is a good source for all types of fairness.... and it creates unpredictability that reduces risks of certain attacks.

%The basic understanding that ordering transactions can be separated from execution has been suggested before (e.g., in Hyperledger Fabric), but ordering was always done after execution \red{(ref?)}. In Concord we do it the other way around. This enables us to do new things, specifically, we can order opaque transactions that are revealed only after ordering. This introduces many risks but it also has many advantages. First and foremost, ordering opaque transactions can guarantee fairness in the sense that users . As a matter of fact, the logic of reducing nodes' information prior to the ordering being established is a general design pattern in Concord. It is also used in Concord's anonymous communication protocol that is used to forward transactions.

%Instead of running the original PBFT protocol that allows write operations to many slots simultaneously but also suffers greatly from view changes. The blockchain construction helps in reaching a higher degree of consistency between the participants, a safer way to sync new nodes and to guarantee the common ledger cannot be tampered with. 

%Concord was designed with a deterioration logic where safety is above all.....

%On the tension between protocols that give much freedom to such that do not - correlated sampling....

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%This paper introduces Concord, a novel consensus protocol focused on the ordering of transactions. It does not relate any semantics to the transactions it orders and is completely unaware of a state these transactions produce by invoking operations. It thus becomes possible to have it completely blind to the transactions it orders. This is achieved by a threshold encryption scheme that obfuscates the transactions from the entities engaged in the consensus protocol. Only when the order has been decided and can no longer be modified is the content of the transactions revealed. The threshold encryption scheme, in its turn, can be further used to produce publicly-verifiable randomness within the protocol. This randomness is used twice. First, we realize a correlated sampling scheme to reduce the freedom nodes have when constructing blocks. 
%Second, we sort the nodes to specific roles - primary and committee. Instead of having all nodes engaged in the protocol, only the committee members do - this serves as an efficient decoupling mechanism that separates $n$ from $f$. While in most consensus protocols, a clear relation between $n$ and $f$ is assumed, we enable the two parameters to be independent. This is important for maximizing performance when a network can be built with a large $n$ while a small $f$ can be guaranteed. The relationship between $f$ and $n$ serves as a difficulty to utilize classic consensus paradigms for semi-open networks where nodes are assumed to have a high degree of trustworthiness (and are faulty with very low probability) and the network aims to be large.

%Concord is not PoW nor is it PoS. Since it assumes a permissioned environment, it can also assume identified consensus nodes. Thus, a reputation mechanism can be quite easily enforced - where nodes are incentivized to maintain high reputation, while the reputation measures “correct” participation and is automatically updated according to behaviors that can be determined undisputedly on the blockchain.
%We also introduce 2 communication schemes used in the protocol when nodes wish to exchange messages. Either a scheme that maximizes anonymity is used (as an obfuscation method that reduces nodes’ information) or a fast scheme is used as an optimization of broadcast dissemination time in a permissioned network. Both schemes are bandwidth economic and tolerant to Byzantine nodes.



