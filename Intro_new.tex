%Background
%Nakamoto consensus 
As the blockchain space matures, different variants of the technology emerge, each with its different strengths and weaknesses. The Nakamoto consensus~\cite{Bitcoin} was first to realize a permissionless membership model, mitigating Sybil attacks and reducing communication complexity by integrating the ingenious Proof-of-Work~\cite{PoW} (PoW) mechanism. While the incentive structure of PoW-based blockchains proved successful in bringing many competitors to the mining game, thereby increasing the security and resilience of the system, it created a paradigm that is extremely slow and expensive. Its exceptionally open nature coincides with its ability to facilitate a large number of miners, but restricts its transaction throughput. Transaction confirmation is slow and finality is asymptotically approached but never really obtained. Moreover, miners' interests are only partially aligned with those of the users---they first and foremost wish to solve PoW puzzles rather than execute and validate smart contracts~\cite{Verifier's_Dilemma}.
%Gruffalo takes this a step further and improves on scalability and fairness that are material to business viable open networks. It also relies on...

%PoW variants
Variants of the original PoW-based blockchain protocol try to improve certain aspects of it, while maintaining PoW as a key factor. Byzcoin~\cite{Byzcoin} offers finality in a PoW-based blockchain by introducing a PBFT~\cite{PBFT} layer among a committee of recent block finders. Technologies based on block-DAGs are good examples for recently suggested solutions to some scalability and speed issues with PoW. These include %IOTA~\cite{IOTA} that offer a fee-less block-DAG and 
GHOST~\cite{Ghost}, which offers an alternative to the longest chain rule whose resilience does not deteriorate when the block rate is high; and SPECTRE~\cite{Spectre}, which gives up the concept of a chain of blocks altogether and suggests a virtual voting algorithm to determine the order of blocks in a block-DAG.

%Non PoW
Parallel to Nakamoto consensus variants, we see proliferation of additional protocols and blockchains, inspired by ideas from the domain of distributed systems. These try to mitigate some of the fundamental problems with PoW, and develop cheap and fast consensus without the excess work associated with the latter. 
%Many of these ideas comply with the so-called Proof-of-Stake (PoS) paradigm that replaces miners for stake holders. 
An interesting protocol in this regard is Algorand~\cite{AlgorandV9}, which cleverly introduces a cheap way to incorporate common randomness and use it to select a block leader, emulating the native randomness incorporated in PoW. Another protocol that alternates block leaders is Tendermint~\cite{Tendermint}, which introduces a procedure for continuous primary rotation over a PBFT~\cite{PBFT} variant. Other attempts to design consensus protocols for a business-oriented environment focus on assuring a degree of fairness among the participating nodes by being resilient to transaction censorship. A good example is HoneyBadgerBFT~\cite{HoneyBadger}, where initially encrypted transactions are included in blocks, and only after their order is finalized, the transactions are revealed.
%Federated consensus, developed by Ripple~\cite{Ripple} and Stellar~\cite{Stellar} is an innovative approach that aims to open classic consensus protocols by allowing nodes to set \emph{trust groups} individually. While these ideas show promising future and may be proven secure and scalable, for the time being, they still serve as an experiment. 
%Classic consensus
%A more conservative approach is to take classic consensus protocols, formally proven and widely tested in production environments, and tweak them to . Suggestions such as these include HoneyBadgerBFT~\cite{HoneyBadger} which ties together a few protocols to construct a leader-less consensus protocol which is censorship resilient.  


%PBFT and committees
%improve this paragraph
\name borrows from these ideas to achieve a fast, scalable, and fair consensus protocol that is highly suited to the business requirements of modern applications. \name relies on PBFT for Byzantine fault tolerance. In fact, \name can be interpreted as a blockchain construction on top of PBFT, based on randomly-elected committees, which enables it to run many individual instances of PBFT sequentially, each responsible for a single value (block). It inherits PBFT's finality, eliminating the possibility of natural forks in the blockchain. And it restricts the agreement process to a bounded-size committee, selected from the larger set of all consensus nodes, in order to mitigate PBFT's inherent difficulty to scale to large networks. 
The committee size is determined according to some conservative upper bound on the number of faulty nodes, $f$. In PBFT, whenever the number of participating nodes $n$ satisfies $n > 3f+1$,  performance is sacrificed for redundant security.
%The committee size is determined according to the strictest bound on the number of faulty nodes that can be assumed, $f$. In PBFT, if $f < \lfloor \frac{n-1}{3} \rfloor$, then performance is sacrificed for redundant security. 
In \nameNS, performance is optimized even when $n$ is large, by setting the elected committee's size to be $m=3f+1$, possibly satisfying $m < n$, which is the smallest committee size that retains PBFT's properties. To provide resilience against DoS attacks, the re-election of these committees is frequent and unpredictable. 

%Incentives
\name explicitly defines the interests driving its consensus nodes and emphasizes fairness among them in regard to these definitions. Specifically, it focuses on ensuring fair distribution of power among the nodes and on guaranteeing that the order of transactions on the blockchain cannot be manipulated by a single node (or a small coalition). \name also takes into account the end-users of the protocol and aims to protect them from being censored. 
%It also strives to comply with the scalability requirements driven by the \red{market's direction}.

%Ordering -> encryption -> randomness
\name concentrates on the \emph{ordering} of transactions. It does not attribute semantics to the transactions it arranges and is completely unaware of state changes these transactions may invoke\footnote{The execution and validation of transactions is beyond the scope of this paper. We mention though, that under the abstraction of a well-defined order (obtained by \nameNS), invalid transactions can simply be skipped by the execution service.}. It is therefore possible to use threshold encryption to obfuscate the transactions from the nodes. Once the position of a transaction becomes final, its content is revealed.  
%The threshold encryption scheme is further used to produce publicly-verifiable randomness within the protocol. As was shown in~\cite{BticoinPublicRandomSource}, public randomness is produced also in the Bitcoin blockchain. While in Bitcoin this is a side effect, in \name this randomness has two distinct uses. One use is to elect the committees mentioned above in a non-predictable or manipulable manner. The other use is to realize correlated sampling and use it to emulate random sampling of one's pool of pending transactions in a verifiable way.
%The threshold encryption scheme is further used to produce verifiable randomness within the protocol. As was shown in many previous works such as~\cite{SCRAP},~\cite{AlgorandV9},~\cite{Dfinity}, verifiable randomness can be produced in MPC in many ways, requiring more or less communication. Helix incorporates the randomness generating scheme into the blockchain such that no extra communication is needed. In addition, the randomness has two distinct uses. One use is to elect the committees mentioned above in a non-predictable or manipulable manner. The other use is to realize correlated sampling and use it to emulate random sampling of one's pool of pending transactions in a fair and verifiable way.

%The threshold encryption scheme is further used to produce verifiable randomness within the protocol. \name incorporates a randomness generation scheme into the protocol without requiring any additional rounds of communication. It then makes use of randomness in two places: first, to elect the committees in a non-predictable and non-manipulable manner; and second, to realize correlated sampling~\cite{HashSample1}, which is used to select pending transactions to blocks in a fair and verifiable way. The problem of using multiparty computation to produce verifiable randomness has a long history both in and apart from the context of cryptocurrencies~\cite{SCRAP},~\cite{AlgorandV9},~\cite{Dfinity}. 

The threshold encryption scheme is further used to produce verifiable randomness within the protocol. \name realizes a randomness beacon without requiring additional rounds of communication\footnote{We note that the problem of using multi-party computation to produce verifiable randomness has a long history both in and apart from the context of blockchains~\cite{SCRAP,AlgorandV9,Dfinity}.}. It then makes use of the randomness in two respects: first, to elect leaders (and committees, which are used to address scalability concerns, as PBFT does not scale adequately to large networks) in an unpredictable and non-manipulable manner; and second, to realize correlated sampling~\cite{HashSample1}, which is used to force nodes to randomly sample their pool of pending transactions when constructing blocks. The correlated sampling scheme enables new fee models (e.g., constant fees) that differ from traditional approaches and prevent the emergence of undesired fee markets.



%membership model
%While PoW permits an open membership model among the consensus nodes, classic consensus protocols normally assume closed membership that can change only periodically (and not continuously). 
\name assumes a known list of consensus nodes responsible for constructing and validating blocks. Such a list can be defined and modified frequently with various governance schemes---permissioned, based on an authority that explicitly determines the composition of the list; or permissionless, based on stake in the system, PoW or other criteria. For simplicity, through the course of this paper we assume that a set of consensus nodes is given. 
%The periodic closeness of the consensus nodes and the assumption they are identified allows Gruffalo to introduce a reputation measure which estimates a node's compatibility with the protocol's instructions and is used to compensate/punish a node in order to incentivize correct behavior.
The fact that consensus nodes are identified allows \name to introduce a reputation measure, which estimates a node's compatibility with the protocol's instructions. The reputation measure is used to compensate or punish a node, incentivizing correct behavior. %A more elaborate discussion of the reputation measure is left for a future work.

We explicitly mention our three main contributions. First, \name achieves consensus over a \textbf{fair} ordering of transactions, where each block includes an unbiased set of transactions. Put differently, a node cannot prioritize transactions she favors and include them in the block she constructs. Such a restriction enables scenarios where transactions fees cover only the processing costs of a transaction but bare no revenue. In such scenarios nodes prioritize transactions according to other criteria\footnote{For example, we can think of nodes as application developers that prioritize transactions made by their own users.} and such type of fairness becomes relevant. Second, in \name \textbf{end-users}, which do not take active part in the consensus protocol, enjoy protection from being censored or discriminated against by the nodes that connect them to the network. This is achieved by having the users encrypt their transactions prior to transferring them to their nodes. Finally, while many consensus protocols rely on a stable leader to progress rapidly and suffer great latencies from leader substitution, \nameNS, under normal flow, efficiently rotates leaders (and committee members). The leader rotation comes only with negligible communication overhead and, unlike other protocols that use a round-robin scheme, is unpredictable and can be weighted non-equally between the nodes. 

%Paper overview
The remainder of the paper is organized as follows. We begin with some short background in Sec.~\ref{section_background}, covering basic concepts in distributed systems and a few cryptography primitives used by \nameNS. Then, in Sec.~\ref{section_model} we describe our system model. In Sec.~\ref{section_Protocol} we give a detailed description of the \name protocol. Sec.~\ref{section_properties} is dedicated to prove basic properties \name satisfies. In Sec.~\ref{section_highload} we focus on epochs with high transaction rates and suggest a sampling scheme to construct blocks in a fair manner. Finally, in Sec.~\ref{section_syncs} we propose a method to synchronize nodes rapidly.